"""OSV (Open Source Vulnerabilities) database client."""

import asyncio
from datetime import datetime
from typing import List, Dict, Any, Optional

import httpx

from ..models import Dependency, Vulnerability, SeverityLevel, PackageManager
from ..config import Config
from ..exceptions import VulnerabilityDatabaseError, NetworkError, RateLimitError


class OSVClient:
    """Client for querying the OSV vulnerability database."""
    
    def __init__(self):
        self.base_url = Config.OSV_API_URL
        self.timeout = 30.0
        self.rate_limit_delay = 1.0  # Delay between requests to respect rate limits
    
    async def query_vulnerabilities(self, dependency: Dependency) -> List[Vulnerability]:
        """
        Query OSV database for vulnerabilities affecting a dependency.
        
        Args:
            dependency: Dependency to check for vulnerabilities
            
        Returns:
            List[Vulnerability]: Found vulnerabilities
        """
        try:
            # Create query payload
            query_payload = self._create_query_payload(dependency)
            
            if not query_payload:
                return []
            
            # Rate limiting
            await asyncio.sleep(self.rate_limit_delay)
            
            # Make API request
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.post(
                    f"{self.base_url}/v1/query",
                    json=query_payload,
                    headers={"Content-Type": "application/json"}
                )
                
                if response.status_code == 429:
                    raise RateLimitError("OSV API rate limit exceeded")
                
                response.raise_for_status()
                data = response.json()
            
            # Parse vulnerabilities from response
            vulnerabilities = []
            for vuln_data in data.get("vulns", []):
                vulnerability = self._parse_vulnerability(vuln_data, dependency)
                if vulnerability:
                    vulnerabilities.append(vulnerability)
            
            return vulnerabilities
            
        except httpx.TimeoutException as e:
            raise NetworkError(f"OSV API timeout: {str(e)}") from e
        except httpx.RequestError as e:
            raise NetworkError(f"OSV API request error: {str(e)}") from e
        except Exception as e:
            raise VulnerabilityDatabaseError(f"OSV query failed: {str(e)}") from e
    
    def _create_query_payload(self, dependency: Dependency) -> Optional[Dict[str, Any]]:
        """Create OSV query payload for a dependency."""
        # Map package managers to OSV ecosystems
        ecosystem_mapping = {
            PackageManager.NPM: "npm",
            PackageManager.PIP: "PyPI",
            PackageManager.MAVEN: "Maven",
            PackageManager.GRADLE: "Maven",  # Gradle uses Maven repositories
            PackageManager.CARGO: "crates.io",
            PackageManager.GO_MOD: "Go",
            PackageManager.COMPOSER: "Packagist",
            PackageManager.NUGET: "NuGet"
        }
        
        ecosystem = ecosystem_mapping.get(dependency.package_manager)
        if not ecosystem:
            return None
        
        # Handle special cases for package names
        package_name = dependency.name
        
        # Maven packages need special handling
        if dependency.package_manager in [PackageManager.MAVEN, PackageManager.GRADLE]:
            if ":" in package_name:
                # Convert groupId:artifactId to groupId/artifactId for OSV
                package_name = package_name.replace(":", "/")
        
        return {
            "package": {
                "ecosystem": ecosystem,
                "name": package_name
            },
            "version": dependency.version
        }
    
    def _parse_vulnerability(self, vuln_data: Dict[str, Any], dependency: Dependency) -> Optional[Vulnerability]:
        """Parse OSV vulnerability data into our Vulnerability model."""
        try:
            vuln_id = vuln_data.get("id", "")
            summary = vuln_data.get("summary", "")
            
            if not vuln_id or not summary:
                return None
            
            # Extract CVE ID if present
            cve_id = None
            aliases = vuln_data.get("aliases", [])
            for alias in aliases:
                if alias.startswith("CVE-"):
                    cve_id = alias
                    break
            
            # Determine severity
            severity = self._determine_severity(vuln_data)
            
            # Extract affected versions
            affected_versions = []
            fixed_versions = []
            
            for affected in vuln_data.get("affected", []):
                package_info = affected.get("package", {})
                if package_info.get("name") == dependency.name:
                    # Extract version ranges
                    ranges = affected.get("ranges", [])
                    for range_info in ranges:
                        events = range_info.get("events", [])
                        for event in events:
                            if "introduced" in event:
                                affected_versions.append(event["introduced"])
                            elif "fixed" in event:
                                fixed_versions.append(event["fixed"])
            
            # Extract references
            references = []
            for ref in vuln_data.get("references", []):
                if "url" in ref:
                    references.append(ref["url"])
            
            # Parse dates
            published_date = None
            modified_date = None
            
            if "published" in vuln_data:
                try:
                    published_date = datetime.fromisoformat(vuln_data["published"].replace("Z", "+00:00"))
                except ValueError:
                    pass
            
            if "modified" in vuln_data:
                try:
                    modified_date = datetime.fromisoformat(vuln_data["modified"].replace("Z", "+00:00"))
                except ValueError:
                    pass
            
            return Vulnerability(
                cve_id=cve_id,
                advisory_id=vuln_id,
                severity=severity,
                summary=summary,
                affected_versions=affected_versions,
                fixed_versions=fixed_versions,
                references=references,
                published_date=published_date,
                modified_date=modified_date
            )
            
        except Exception as e:
            print(f"Error parsing OSV vulnerability: {e}")
            return None
    
    def _determine_severity(self, vuln_data: Dict[str, Any]) -> SeverityLevel:
        """Determine severity level from OSV vulnerability data."""
        # Check for CVSS score
        severity_info = vuln_data.get("severity", [])
        
        for severity in severity_info:
            if severity.get("type") == "CVSS_V3":
                score = severity.get("score")
                if score is not None:
                    if score >= 9.0:
                        return SeverityLevel.CRITICAL
                    elif score >= 7.0:
                        return SeverityLevel.HIGH
                    elif score >= 4.0:
                        return SeverityLevel.MEDIUM
                    else:
                        return SeverityLevel.LOW
        
        # Fallback to database-specific severity
        database_specific = vuln_data.get("database_specific", {})
        severity_str = database_specific.get("severity", "").upper()
        
        if severity_str in ["CRITICAL", "HIGH", "MEDIUM", "LOW"]:
            return SeverityLevel(severity_str)
        
        # Default to unknown
        return SeverityLevel.UNKNOWN
    
    async def batch_query_vulnerabilities(self, dependencies: List[Dependency]) -> Dict[str, List[Vulnerability]]:
        """
        Query vulnerabilities for multiple dependencies with rate limiting.
        
        Args:
            dependencies: List of dependencies to check
            
        Returns:
            Dict[str, List[Vulnerability]]: Mapping of dependency names to vulnerabilities
        """
        results = {}
        
        for dependency in dependencies:
            try:
                vulnerabilities = await self.query_vulnerabilities(dependency)
                results[dependency.name] = vulnerabilities
            except Exception as e:
                print(f"Failed to query vulnerabilities for {dependency.name}: {e}")
                results[dependency.name] = []
        
        return results