"""Unified vulnerability scanning interface."""

from typing import List, Dict, Any, Optional
from datetime import datetime

from ..models import RepositoryAnalysis, Dependency, Vulnerability, SecurityAnalysisResult, SeverityLevel
from ..streaming import StreamingQueue, ProgressTracker
from ..exceptions import VulnerabilityDatabaseError
from .osv_client import OSVClient
from .github_advisories import GitHubAdvisoriesClient
from .cache import vulnerability_cache


class VulnerabilityScanner:
    """Unified vulnerability scanner that queries multiple databases."""
    
    def __init__(self):
        self.osv_client = OSVClient()
        self.github_client = GitHubAdvisoriesClient()
        self.cache = vulnerability_cache
    
    async def scan_vulnerabilities(
        self,
        analysis: RepositoryAnalysis,
        queue: Optional[StreamingQueue] = None
    ) -> SecurityAnalysisResult:
        """
        Scan repository dependencies for vulnerabilities.
        
        Args:
            analysis: Repository analysis results
            queue: Optional streaming queue for progress updates
            
        Returns:
            SecurityAnalysisResult: Security analysis with vulnerabilities
        """
        progress = ProgressTracker(queue, total_steps=100) if queue else None
        
        try:
            if progress:
                await progress.update(10, "Starting vulnerability scan")
            
            if not analysis.dependencies:
                if queue:
                    await queue.put("⚠️ No dependencies to scan for vulnerabilities")
                
                return SecurityAnalysisResult(
                    repository_analysis=analysis,
                    vulnerabilities=[],
                    total_vulnerabilities=0
                )
            
            if progress:
                await progress.update(20, f"Scanning {len(analysis.dependencies)} dependencies")
            
            all_vulnerabilities = []
            total_deps = len(analysis.dependencies)
            processed_deps = 0
            
            # Scan each dependency
            for dependency in analysis.dependencies:
                if progress:
                    progress_pct = 20 + (processed_deps / total_deps) * 60
                    await progress.update(int(progress_pct), f"Scanning {dependency.name}")
                
                dep_vulnerabilities = await self._scan_dependency(dependency, queue)
                all_vulnerabilities.extend(dep_vulnerabilities)
                
                processed_deps += 1
            
            if progress:
                await progress.update(85, "Analyzing vulnerability data")
            
            # Remove duplicates
            unique_vulnerabilities = self._deduplicate_vulnerabilities(all_vulnerabilities)
            
            # Create security analysis result
            result = SecurityAnalysisResult(
                repository_analysis=analysis,
                vulnerabilities=unique_vulnerabilities
            )
            
            if progress:
                await progress.complete(f"Vulnerability scan complete: {len(unique_vulnerabilities)} vulnerabilities found")
            
            if queue:
                await queue.put(f"🔍 Vulnerability scan completed!")
                await queue.put(f"📊 Found {len(unique_vulnerabilities)} unique vulnerabilities")
                await queue.put(f"🚨 Critical: {result.critical_count}, High: {result.high_count}, Medium: {result.medium_count}, Low: {result.low_count}")
            
            return result
            
        except Exception as e:
            error_msg = f"Vulnerability scan failed: {str(e)}"
            if queue:
                await queue.put(f"❌ {error_msg}")
            
            return SecurityAnalysisResult(
                repository_analysis=analysis,
                vulnerabilities=[],
                total_vulnerabilities=0
            )
    
    async def _scan_dependency(self, dependency: Dependency, queue: Optional[StreamingQueue] = None) -> List[Vulnerability]:
        """Scan a single dependency for vulnerabilities."""
        vulnerabilities = []
        
        # Check cache first
        osv_cached = await self.cache.get(dependency, "osv")
        github_cached = await self.cache.get(dependency, "github")
        
        # Query OSV database
        if osv_cached is not None:
            osv_vulnerabilities = osv_cached
            if queue:
                await queue.put(f"📋 Using cached OSV data for {dependency.name}")
        else:
            try:
                osv_vulnerabilities = await self.osv_client.query_vulnerabilities(dependency)
                await self.cache.set(dependency, "osv", osv_vulnerabilities)
                if queue and osv_vulnerabilities:
                    await queue.put(f"🔍 Found {len(osv_vulnerabilities)} OSV vulnerabilities for {dependency.name}")
            except Exception as e:
                print(f"OSV query failed for {dependency.name}: {e}")
                osv_vulnerabilities = []
        
        vulnerabilities.extend(osv_vulnerabilities)
        
        # Query GitHub Security Advisories
        if github_cached is not None:
            github_vulnerabilities = github_cached
            if queue:
                await queue.put(f"📋 Using cached GitHub data for {dependency.name}")
        else:
            try:
                github_vulnerabilities = await self.github_client.query_vulnerabilities(dependency)
                await self.cache.set(dependency, "github", github_vulnerabilities)
                if queue and github_vulnerabilities:
                    await queue.put(f"🔍 Found {len(github_vulnerabilities)} GitHub vulnerabilities for {dependency.name}")
            except Exception as e:
                print(f"GitHub advisories query failed for {dependency.name}: {e}")
                github_vulnerabilities = []
        
        vulnerabilities.extend(github_vulnerabilities)
        
        return vulnerabilities
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """Remove duplicate vulnerabilities based on CVE ID or advisory ID."""
        seen_ids = set()
        unique_vulnerabilities = []
        
        for vuln in vulnerabilities:
            # Use CVE ID if available, otherwise use advisory ID
            identifier = vuln.cve_id if vuln.cve_id else vuln.advisory_id
            
            if identifier not in seen_ids:
                seen_ids.add(identifier)
                unique_vulnerabilities.append(vuln)
        
        return unique_vulnerabilities
    
    async def generate_remediation_suggestions(self, vulnerabilities: List[Vulnerability]) -> List[Dict[str, Any]]:
        """
        Generate remediation suggestions for vulnerabilities.
        
        Args:
            vulnerabilities: List of vulnerabilities to analyze
            
        Returns:
            List[Dict[str, Any]]: Remediation suggestions
        """
        suggestions = []
        
        # Group vulnerabilities by severity
        severity_groups = {
            SeverityLevel.CRITICAL: [],
            SeverityLevel.HIGH: [],
            SeverityLevel.MEDIUM: [],
            SeverityLevel.LOW: []
        }
        
        for vuln in vulnerabilities:
            if vuln.severity in severity_groups:
                severity_groups[vuln.severity].append(vuln)
        
        # Generate suggestions based on severity
        if severity_groups[SeverityLevel.CRITICAL]:
            suggestions.append({
                "priority": "IMMEDIATE",
                "action": "Update Critical Dependencies",
                "description": f"Immediately update {len(severity_groups[SeverityLevel.CRITICAL])} dependencies with critical vulnerabilities",
                "vulnerabilities": [v.advisory_id for v in severity_groups[SeverityLevel.CRITICAL][:5]]
            })
        
        if severity_groups[SeverityLevel.HIGH]:
            suggestions.append({
                "priority": "HIGH",
                "action": "Update High-Risk Dependencies",
                "description": f"Update {len(severity_groups[SeverityLevel.HIGH])} dependencies with high-severity vulnerabilities within 7 days",
                "vulnerabilities": [v.advisory_id for v in severity_groups[SeverityLevel.HIGH][:5]]
            })
        
        if severity_groups[SeverityLevel.MEDIUM]:
            suggestions.append({
                "priority": "MEDIUM",
                "action": "Review Medium-Risk Dependencies",
                "description": f"Review and plan updates for {len(severity_groups[SeverityLevel.MEDIUM])} dependencies with medium-severity vulnerabilities",
                "vulnerabilities": [v.advisory_id for v in severity_groups[SeverityLevel.MEDIUM][:3]]
            })
        
        # Add general suggestions
        if vulnerabilities:
            suggestions.append({
                "priority": "ONGOING",
                "action": "Implement Dependency Monitoring",
                "description": "Set up automated dependency scanning in your CI/CD pipeline to catch vulnerabilities early",
                "vulnerabilities": []
            })
            
            suggestions.append({
                "priority": "ONGOING",
                "action": "Regular Security Audits",
                "description": "Perform regular security audits of your dependencies and keep them updated",
                "vulnerabilities": []
            })
        
        return suggestions
    
    async def get_vulnerability_summary(self, result: SecurityAnalysisResult) -> Dict[str, Any]:
        """
        Generate a summary of vulnerability analysis results.
        
        Args:
            result: Security analysis result
            
        Returns:
            Dict[str, Any]: Vulnerability summary
        """
        summary = {
            "total_dependencies": result.repository_analysis.total_dependencies,
            "total_vulnerabilities": result.total_vulnerabilities,
            "risk_score": result.risk_score,
            "severity_breakdown": {
                "critical": result.critical_count,
                "high": result.high_count,
                "medium": result.medium_count,
                "low": result.low_count
            },
            "scan_timestamp": result.repository_analysis.scan_timestamp.isoformat(),
            "repository_url": result.repository_analysis.repository_url,
            "branch": result.repository_analysis.branch
        }
        
        # Add top vulnerabilities
        top_vulnerabilities = sorted(
            result.vulnerabilities,
            key=lambda v: {"CRITICAL": 4, "HIGH": 3, "MEDIUM": 2, "LOW": 1}.get(v.severity.value, 0),
            reverse=True
        )[:10]
        
        summary["top_vulnerabilities"] = [
            {
                "id": vuln.cve_id or vuln.advisory_id,
                "severity": vuln.severity.value,
                "summary": vuln.summary[:100] + "..." if len(vuln.summary) > 100 else vuln.summary
            }
            for vuln in top_vulnerabilities
        ]
        
        return summary