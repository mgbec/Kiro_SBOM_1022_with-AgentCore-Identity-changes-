"""GitHub Security Advisories client."""

import asyncio
from datetime import datetime
from typing import List, Dict, Any, Optional

import httpx

from ..models import Dependency, Vulnerability, SeverityLevel, PackageManager
from ..config import Config
from ..auth import get_auth_headers
from ..exceptions import VulnerabilityDatabaseError, NetworkError, RateLimitError, AuthenticationError


class GitHubAdvisoriesClient:
    """Client for querying GitHub Security Advisories."""
    
    def __init__(self):
        self.base_url = Config.GITHUB_ADVISORIES_URL
        self.timeout = 30.0
        self.rate_limit_delay = 1.0
    
    async def query_vulnerabilities(self, dependency: Dependency) -> List[Vulnerability]:
        """
        Query GitHub Security Advisories for vulnerabilities affecting a dependency.
        
        Args:
            dependency: Dependency to check for vulnerabilities
            
        Returns:
            List[Vulnerability]: Found vulnerabilities
        """
        try:
            # Map package manager to GitHub ecosystem
            ecosystem = self._get_github_ecosystem(dependency.package_manager)
            if not ecosystem:
                return []
            
            # Rate limiting
            await asyncio.sleep(self.rate_limit_delay)
            
            # Build query parameters
            params = {
                "ecosystem": ecosystem,
                "package": dependency.name,
                "per_page": 100,
                "sort": "published",
                "direction": "desc"
            }
            
            # Make API request
            try:
                headers = get_auth_headers()
            except AuthenticationError:
                # Fall back to unauthenticated requests (lower rate limit)
                headers = {"Accept": "application/vnd.github+json"}
            
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.get(
                    self.base_url,
                    params=params,
                    headers=headers
                )
                
                if response.status_code == 429:
                    raise RateLimitError("GitHub Advisories API rate limit exceeded")
                
                if response.status_code == 401:
                    raise AuthenticationError("GitHub API authentication failed")
                
                response.raise_for_status()
                data = response.json()
            
            # Parse vulnerabilities from response
            vulnerabilities = []
            for advisory in data:
                vulnerability = self._parse_advisory(advisory, dependency)
                if vulnerability and self._affects_version(advisory, dependency.version):
                    vulnerabilities.append(vulnerability)
            
            return vulnerabilities
            
        except httpx.TimeoutException as e:
            raise NetworkError(f"GitHub Advisories API timeout: {str(e)}") from e
        except httpx.RequestError as e:
            raise NetworkError(f"GitHub Advisories API request error: {str(e)}") from e
        except Exception as e:
            raise VulnerabilityDatabaseError(f"GitHub Advisories query failed: {str(e)}") from e
    
    def _get_github_ecosystem(self, package_manager: PackageManager) -> Optional[str]:
        """Map package manager to GitHub ecosystem identifier."""
        ecosystem_mapping = {
            PackageManager.NPM: "npm",
            PackageManager.PIP: "pip",
            PackageManager.MAVEN: "maven",
            PackageManager.GRADLE: "maven",
            PackageManager.CARGO: "cargo",
            PackageManager.GO_MOD: "go",
            PackageManager.COMPOSER: "composer",
            PackageManager.NUGET: "nuget"
        }
        
        return ecosystem_mapping.get(package_manager)
    
    def _parse_advisory(self, advisory: Dict[str, Any], dependency: Dependency) -> Optional[Vulnerability]:
        """Parse GitHub advisory data into our Vulnerability model."""
        try:
            ghsa_id = advisory.get("ghsa_id", "")
            summary = advisory.get("summary", "")
            
            if not ghsa_id or not summary:
                return None
            
            # Extract CVE ID
            cve_id = advisory.get("cve_id")
            
            # Determine severity
            severity = self._parse_severity(advisory.get("severity", "unknown"))
            
            # Extract affected and fixed versions
            affected_versions = []
            fixed_versions = []
            
            vulnerabilities = advisory.get("vulnerabilities", [])
            for vuln in vulnerabilities:
                package_info = vuln.get("package", {})
                if package_info.get("name") == dependency.name:
                    # Parse version ranges
                    vulnerable_version_range = vuln.get("vulnerable_version_range", "")
                    if vulnerable_version_range:
                        affected_versions.append(vulnerable_version_range)
                    
                    # Parse patched versions
                    patched_versions = vuln.get("patched_versions", [])
                    fixed_versions.extend(patched_versions)
            
            # Extract references
            references = []
            if advisory.get("html_url"):
                references.append(advisory["html_url"])
            
            for ref in advisory.get("references", []):
                if "url" in ref:
                    references.append(ref["url"])
            
            # Parse dates
            published_date = None
            updated_date = None
            
            if "published_at" in advisory:
                try:
                    published_date = datetime.fromisoformat(advisory["published_at"].replace("Z", "+00:00"))
                except ValueError:
                    pass
            
            if "updated_at" in advisory:
                try:
                    updated_date = datetime.fromisoformat(advisory["updated_at"].replace("Z", "+00:00"))
                except ValueError:
                    pass
            
            return Vulnerability(
                cve_id=cve_id,
                advisory_id=ghsa_id,
                severity=severity,
                summary=summary,
                affected_versions=affected_versions,
                fixed_versions=fixed_versions,
                references=references,
                published_date=published_date,
                modified_date=updated_date
            )
            
        except Exception as e:
            print(f"Error parsing GitHub advisory: {e}")
            return None
    
    def _parse_severity(self, severity_str: str) -> SeverityLevel:
        """Parse GitHub severity string to our SeverityLevel enum."""
        severity_mapping = {
            "critical": SeverityLevel.CRITICAL,
            "high": SeverityLevel.HIGH,
            "medium": SeverityLevel.MEDIUM,
            "moderate": SeverityLevel.MEDIUM,  # GitHub uses "moderate"
            "low": SeverityLevel.LOW,
            "unknown": SeverityLevel.UNKNOWN
        }
        
        return severity_mapping.get(severity_str.lower(), SeverityLevel.UNKNOWN)
    
    def _affects_version(self, advisory: Dict[str, Any], version: str) -> bool:
        """
        Check if the advisory affects the given version.
        
        This is a simplified version check. In production, you'd want
        to use a proper semantic version comparison library.
        """
        try:
            vulnerabilities = advisory.get("vulnerabilities", [])
            
            for vuln in vulnerabilities:
                vulnerable_range = vuln.get("vulnerable_version_range", "")
                
                # Simple checks for common patterns
                if not vulnerable_range:
                    continue
                
                # Handle "< version" pattern
                if vulnerable_range.startswith("< "):
                    max_version = vulnerable_range[2:].strip()
                    # Simplified: assume version is affected if it's not "unknown"
                    if version != "unknown" and version != max_version:
                        return True
                
                # Handle ">= version" pattern
                elif vulnerable_range.startswith(">= "):
                    min_version = vulnerable_range[3:].strip()
                    if version != "unknown":
                        return True
                
                # Handle exact version matches
                elif version in vulnerable_range:
                    return True
            
            return False
            
        except Exception:
            # If we can't determine, assume it might be affected
            return True
    
    async def batch_query_vulnerabilities(self, dependencies: List[Dependency]) -> Dict[str, List[Vulnerability]]:
        """
        Query vulnerabilities for multiple dependencies with rate limiting.
        
        Args:
            dependencies: List of dependencies to check
            
        Returns:
            Dict[str, List[Vulnerability]]: Mapping of dependency names to vulnerabilities
        """
        results = {}
        
        for dependency in dependencies:
            try:
                vulnerabilities = await self.query_vulnerabilities(dependency)
                results[dependency.name] = vulnerabilities
            except Exception as e:
                print(f"Failed to query GitHub advisories for {dependency.name}: {e}")
                results[dependency.name] = []
        
        return results