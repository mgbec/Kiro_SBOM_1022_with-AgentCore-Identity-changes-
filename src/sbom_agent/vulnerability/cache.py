"""Vulnerability data caching to reduce API calls."""

import asyncio
import time
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

from ..models import Dependency, Vulnerability
from ..config import Config


@dataclass
class CacheEntry:
    """Cache entry for vulnerability data."""
    data: List[Vulnerability]
    timestamp: float
    ttl: float
    
    def is_expired(self) -> bool:
        """Check if cache entry has expired."""
        return time.time() > (self.timestamp + self.ttl)


class VulnerabilityCache:
    """In-memory cache for vulnerability data."""
    
    def __init__(self, default_ttl: float = Config.CACHE_TTL_SECONDS, max_size: int = Config.MAX_CACHE_SIZE):
        self.default_ttl = default_ttl
        self.max_size = max_size
        self._cache: Dict[str, CacheEntry] = {}
        self._access_times: Dict[str, float] = {}
        self._lock = asyncio.Lock()
    
    def _generate_cache_key(self, dependency: Dependency, source: str) -> str:
        """Generate cache key for a dependency and vulnerability source."""
        return f"{source}:{dependency.package_manager.value}:{dependency.name}:{dependency.version}"
    
    async def get(self, dependency: Dependency, source: str) -> Optional[List[Vulnerability]]:
        """
        Get cached vulnerability data for a dependency.
        
        Args:
            dependency: Dependency to look up
            source: Vulnerability source (e.g., "osv", "github")
            
        Returns:
            Optional[List[Vulnerability]]: Cached vulnerabilities or None if not found/expired
        """
        async with self._lock:
            cache_key = self._generate_cache_key(dependency, source)
            
            if cache_key not in self._cache:
                return None
            
            entry = self._cache[cache_key]
            
            if entry.is_expired():
                # Remove expired entry
                del self._cache[cache_key]
                if cache_key in self._access_times:
                    del self._access_times[cache_key]
                return None
            
            # Update access time
            self._access_times[cache_key] = time.time()
            
            return entry.data
    
    async def set(self, dependency: Dependency, source: str, vulnerabilities: List[Vulnerability], ttl: Optional[float] = None) -> None:
        """
        Cache vulnerability data for a dependency.
        
        Args:
            dependency: Dependency to cache data for
            source: Vulnerability source
            vulnerabilities: Vulnerability data to cache
            ttl: Time to live in seconds (uses default if None)
        """
        async with self._lock:
            cache_key = self._generate_cache_key(dependency, source)
            
            # Use default TTL if not specified
            if ttl is None:
                ttl = self.default_ttl
            
            # Check if we need to evict entries
            if len(self._cache) >= self.max_size:
                await self._evict_lru()
            
            # Store entry
            entry = CacheEntry(
                data=vulnerabilities,
                timestamp=time.time(),
                ttl=ttl
            )
            
            self._cache[cache_key] = entry
            self._access_times[cache_key] = time.time()
    
    async def _evict_lru(self) -> None:
        """Evict least recently used cache entries."""
        if not self._access_times:
            return
        
        # Find least recently used entry
        lru_key = min(self._access_times.keys(), key=lambda k: self._access_times[k])
        
        # Remove from cache
        if lru_key in self._cache:
            del self._cache[lru_key]
        del self._access_times[lru_key]
    
    async def clear(self) -> None:
        """Clear all cached data."""
        async with self._lock:
            self._cache.clear()
            self._access_times.clear()
    
    async def cleanup_expired(self) -> int:
        """
        Remove expired cache entries.
        
        Returns:
            int: Number of entries removed
        """
        async with self._lock:
            expired_keys = []
            
            for key, entry in self._cache.items():
                if entry.is_expired():
                    expired_keys.append(key)
            
            for key in expired_keys:
                del self._cache[key]
                if key in self._access_times:
                    del self._access_times[key]
            
            return len(expired_keys)
    
    def get_stats(self) -> Dict[str, Any]:
        """Get cache statistics."""
        return {
            "total_entries": len(self._cache),
            "max_size": self.max_size,
            "default_ttl": self.default_ttl,
            "memory_usage_estimate": len(self._cache) * 1024  # Rough estimate
        }


# Global cache instance
vulnerability_cache = VulnerabilityCache()